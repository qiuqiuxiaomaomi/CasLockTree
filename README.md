# CasLockTree
深入分析锁，重入锁，轻量级锁，偏向锁，公平锁，volatile, synchonized,

<pre>
volatile 是因为其本身包含“禁止指令重排序”的语义。
  
       可见性：

           是指线程之间的可见性，一个线程修改的状态对另一个线程是可见的。也就是一个线
       程修改的结果。另一个线程马上就能看到。

            Volatile修饰的成员变量在每次被线程访问时，都强迫从共享内存中重读该成员变
       量的值。而且，当成员变量发生变化时，强迫线程将变化值回写到共享内存。这样在任何时刻，
       两个不同的线程总是看到某个成员变量的值是相同的，更简单一点理解就是volatile修饰的
       变量值发生变化时对于另外的线程是可见的。

           比如：用volatile修饰的变量，就会具有可见性。volatile修饰的变量不允许线程内部
       缓存和重排序，即直接修改内存。所以对其他线程是可见的。但是这里需要注意一个
       问题，volatile只能让被他修饰内容具有可见性，但不能保证它具有原子性。
       比如 volatile int a = 0；之后有一个操作 a++；这个变量a具有可见性，但是a++ 依然
       是一个非原子操作，也就是这个操作同样存在线程安全问题
</pre>

![](https://i.imgur.com/RidEMrW.png)

<pre>
synchonized关键字

       Java中每一个对象都可以作为锁，这是synchronized实现同步的基础：

            1）普通同步方法，锁是当前实例对象
            2）静态同步方法，锁是当前类的class对象
            3）同步方法块，锁是括号里面的对象

       通过javap查看生成的class文件，可以发现synchronized的实现：
           同步代码块是使用monitorenter和monitorexit指令实现的。

           任何一个对象都有一个monitor与之相关联，当且一个monitor被持有之后，它将处于锁定
       状态。线程执行到monitorenter指令时，将会尝试获取对象锁对应的monitor所有权，即尝试
       获取对象的锁；

       Java对象头和monitor是实现synchronized的基础。
           synchronized用的锁是存在Java对象头里的，Hotspot虚拟机的对象头主要包括两部
       分数据：Mark Word（标记字段）、Klass Pointer（类型指针）。其中Klass Point是是对
       象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例，
       Mark Word用于存储对象自身的运行时数据，它是实现轻量级锁和偏向锁的关键

       MarkWorld用于存储对象自身的运行时数据，如哈希吗，GC分代年龄，锁状态标志，线程持有的
       锁，偏向线程ID，偏向时间戳等等，Java对象头一般占用2个机器码，每个机器码4个字节，如
       果对象是数组，则需要3个机器码，
</pre>

<pre>
Monitor:
       可以理解为一个同步工具，也可以描述为一种同步机制，它通常被描述为一个对象。
       所有的Java对象是天生的Monitor，每个Java对象都有称为Monitor的潜质，因为在Java的设
       计中，每个Java对象天生内部就有一把看不见的锁，它叫内部锁或者Monitor锁。

       Monitor锁
              Monitor锁是线程私有的数据结构，每一个线程都有一个可用monitor record列表，
       同时还有一个全局的可用列表，每一个被锁住的对象都会和一个monitor关联，对象头的
       MarkWorld中的LockWorld指向monitor的起始地址。同时monitor中有一个Owner字段存放
       拥有该锁的线程的唯一标识，标识该锁被这个线程占用。

       Owner：初始时为Null,表示当前没有任何线程拥有该monitor record，当线程成功拥有该
             锁后保存线程唯一标识，当被释放时又设置为null;
       EntryQ:关联一个互斥锁，阻塞所有视图锁住monitor record失败的线程。
       RcThis:标识blocked或waiting在该monitor record上的所有线程的个数。
       Nest:用来实现重入锁的计数。
       HashCode：保存从对象头拷贝过来的hashcode.

       Candidate:用来避免不必要的阻塞或等待线程唤醒，因为每一次只有一个线程能够成功拥
       有锁，如果每次前一个释放锁的线程唤醒所有正在阻塞或等待的线程，会引起不必要的上下文
       切换（从阻塞到就绪然后因为竞争锁失败又被阻塞）从而导致性能严重下降。Candidate只有
       两种可能的值0表示没有需要唤醒的线程1表示要唤醒一个继任线程来竞争锁
</pre>

<pre>
synchronized是重量级锁，效率很低。

      JDK1.6对锁的实现引入了大量的优化，如自旋锁，锁消除，锁粗话，偏向锁，轻量级锁等技术来
      减少锁操作的开销。

      锁主要存在的四种状态：
          1）无锁状态
          2）偏向锁状态
          3）轻量级锁状态
          5）重量级锁状态

          他们会随着竞争的激烈而逐渐升级，锁可以升级但不可以降级，这种策略是为了提高获得锁
      和释放锁的效率。
</pre>

<pre>
自旋锁：

           线程的阻塞和唤醒需要CPU从用户态转为核心态，频繁的阻塞和唤醒对CPU来说是一件负担
      很重的工作，势必会给系统的并发性能带来很大的压力，同时，在应用中，对象锁的锁状态只会
      持续很短的一段时间，为了这一段很短的时间频繁的阻塞和唤醒线程时非常不值得的，所以引入自旋锁。

           自旋锁：
                 是指让线程等待一段时间，不会被立即挂起，看持有锁的线程是否很快释放锁，通
           过执行一段无意义的循环即可，即自旋。

           优缺点：
                 虽然自旋锁可以避免线程切换带来的开销，但是它占用了CPU时间，如果持有锁的
           线程很快就释放了锁，那么自旋的效率就非常好，反之，自旋的线程就会白白消耗掉处理
           的资源，这样反而会带来性能上的浪费，所以，自旋等待的时间必须要有一个限度，如果
           自旋超过了一定的限度任然没有获取到锁，则应该被挂起。

           在JDK1.6中默认开启。同时自旋的默认次数为10次，可以通过参数-XX:PreBlockSpin来调整
</pre>

<pre>
自适应自旋锁

      JDK 1.6引入了更加聪明的自旋锁，即自适应自旋锁。所谓自适应就意味着自旋的次数不再是固
      定的，它是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。它怎么做呢？线程如
      果自旋成功了，那么下次自旋的次数会更加多，因为虚拟机认为既然上次成功了，那么此次自
      旋也很有可能会再次成功，那么它就会允许自旋等待持续的次数更多。反之，如果对于某个锁，
      很少有自旋能够成功的，那么在以后要或者这个锁的时候自旋的次数会减少甚至省略掉自旋过程，以免浪费处理器资源
</pre>

<pre>
锁消除：
        
          为了保证数据的完整性，我们在进行操作时需要对这部分操作进行同步控制，但是在有些
      情况下，JVM检测到不可能存在共享数据竞争，这是JVM会对这些同步锁进行锁消除。锁消除的
      依据是逃逸分析的数据支持。

          如果不存在竞争，为什么还需要加锁呢？所以锁消除可以节省毫无意义的请求锁的时间。
      变量是否逃逸，对于虚拟机来说需要使用数据流分析来确定，但是对于我们程序员来说这还不
      清楚么？我们会在明明知道不存在数据竞争的代码块前加上同步吗？但是有时候程序并不是
      我们所想的那样？我们虽然没有显示使用锁，但是我们在使用一些JDK的内置API时，
      如StringBuffer、Vector、HashTable等，这个时候会存在隐形的加锁操作。比
      如StringBuffer的append()方法，Vector的add()方法：

			public void vectorTest(){
			     Vector<String> vector = new Vector<String>();
			     for(int i = 0 ; i < 10 ; i++){
			         vector.add(i + "");
			     }
			 
			     System.out.println(vector);
			 }
      在运行这段代码时，JVM可以明显检测到变量vector没有逃逸出方法vectorTest()之外，所
      以JVM可以大胆地将vector内部的加锁操作消除。
</pre>

<pre>
锁粗化

      在使用同步锁的时候，需要让同步块的作用范围尽可能小—仅在共享数据的实际作用域中才进行
   同步，这样做的目的是为了使需要同步的操作数量尽可能缩小，如果存在锁竞争，那么等待锁的线
   程也能尽快拿到锁。

      在大多数的情况下，上述观点是正确的，但是如果一系列的连续加锁解锁操作，可能会导致不
   必要的性能损耗，所以引入锁粗话的概念。
  
      锁粗化就是将多个连续的加锁、解锁操作连接在一起，扩展成一个范围更大的锁。如上面实
   例：vector每次add的时候都需要加锁操作，JVM检测到对同一个对象（vector）连续加锁、解锁
   操作，会合并一个更大范围的加锁、解锁操作，即加锁解锁操作会移到for循环之外

</pre>

<pre>
轻量级锁

      引入轻量级锁的主要目的是在许多没有多线程竞争的前提下，减少传统的重量级锁使用操作系
   统互斥量产生的性能消耗。当关闭偏向锁功能或者多个线程竞争偏向锁导致偏向锁升级为轻量级
   锁，则会尝试获取轻量级锁，其步骤如下：

      1）判断当前对象是否处于无锁状态（hashcode, 0, 01），若是，则JVM首先将在当前线程
   的栈帧上建立一个名为锁记录Lock Record的空间，用于存储锁对象目前的Mark World的拷贝，
   官方称之为 Displaced Mark World，如果失败执行步骤3
      2) JVM利用CAS操作试图将对象的Mark World更新为指向Lock Record的指针，如果成功表示
   竞争到锁，则将锁标志位变为00（表示此对象处于轻量级锁状态），执行同步操作，如果失败执行步骤3
      3）判断当前对象的Mark World是否指向当前线程的栈帧，如果是则表示当前线程已经持有当前
   对象的锁，则直接执行同步代码块；否则只能说明该锁对象已经被其他线程抢占了，这时轻量级锁
   需要膨胀为重量级锁，锁标志位变为01，后面等待的线程将会进入阻塞状态。

      释放锁：
            轻量级锁的释放也是通过CAS操作来实现的，主要步骤如下：
                1）取出获取轻量级锁保存在Displaced Mark World中的数据。
                2）用CAS操作将取出的数据替换当前对象的Mark World，如果成功，则说明释放
                   锁成功，否则实行步骤3
                3）如果CAS操作替换失败，说明有其他线程尝试获取该锁，则需要在释放锁的同时
                   需要唤醒被挂起的线程。

            对于轻量级锁，其性能提升的依据是“对于绝大部分的锁，在整个生命周期内都是不会
            存在竞争的”，如果打破这个依据则除了互斥的开销外，还有额外的CAS操作，因此在有
            多线程竞争的情况下，轻量级锁比重量级锁更慢；
</pre>

<pre>
偏向锁

          引入偏向锁的目的是：为了在无多线程竞争的情况下尽量减少不必要的轻量级锁执行路径，
      上面提到的轻量级锁的加锁，解锁操作是需要依赖多次CAS原子指令的，那么偏向锁是如何来减少
      不必要的CAS操作的呢？

      获取锁步骤：
          1）检测Mark World是否为可偏向状态，即是否为偏向锁1，锁标识为01;
          2) 若为可偏向状态，则测试线程ID是否为当前线程ID，如果是，则执行步骤6，否则执行步骤3；
          3）如果线程ID不为当前线程ID，则通过CAS操作竞争锁，竞争成功，，则将Mark World的
          线程ID替换为当前线程ID，否则执行线程5；
          5）通过CAS竞争锁失败，证明当前存在多线程竞争情况，当达到全局安全点，获得偏向锁
          的线程被挂起，偏向锁升级为轻量级锁，然后被阻塞在安全点的线程继续往下执行同步代码
          块。
          6）执行同步代码块。

      释放锁：
          偏向锁的释放采用了一种只有竞争才会释放锁的机制，线程时不会主动去释放偏向锁，需要
      等待其他线程来竞争，偏向锁的撤销需要等待全局安全点，这个时间点是没有正在执行的代码，其步骤：
            1）暂停拥有偏向锁的线程，判断锁对象是否还处于被锁定的状态。
            2）撤销偏向锁，恢复到无锁状态或者轻量级锁状态。
</pre>

<pre>
重量级锁

      通过对象内部的监视器（monitor）实现，其中monitor的本质是依赖于底层操作系统的
   Mutex Lock实现，操作系统实现线程之间的切换需要从用户态到内核态的切换，切换成本非常高
</pre>