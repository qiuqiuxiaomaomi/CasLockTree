# CasLockTree
深入分析锁，重入锁，轻量级锁，偏向锁，公平锁，volatile, synchonized,

<pre>
volatile 是因为其本身包含“禁止指令重排序”的语义。
  
       可见性：

           是指线程之间的可见性，一个线程修改的状态对另一个线程是可见的。也就是一个线
       程修改的结果。另一个线程马上就能看到。

            Volatile修饰的成员变量在每次被线程访问时，都强迫从共享内存中重读该成员变
       量的值。而且，当成员变量发生变化时，强迫线程将变化值回写到共享内存。这样在任何时刻，
       两个不同的线程总是看到某个成员变量的值是相同的，更简单一点理解就是volatile修饰的
       变量值发生变化时对于另外的线程是可见的。

           比如：用volatile修饰的变量，就会具有可见性。volatile修饰的变量不允许线程内部
       缓存和重排序，即直接修改内存。所以对其他线程是可见的。但是这里需要注意一个
       问题，volatile只能让被他修饰内容具有可见性，但不能保证它具有原子性。
       比如 volatile int a = 0；之后有一个操作 a++；这个变量a具有可见性，但是a++ 依然
       是一个非原子操作，也就是这个操作同样存在线程安全问题
</pre>

![](https://i.imgur.com/RidEMrW.png)

<pre>
synchonized关键字

       Java中每一个对象都可以作为锁，这是synchronized实现同步的基础：

            1）普通同步方法，锁是当前实例对象
            2）静态同步方法，锁是当前类的class对象
            3）同步方法块，锁是括号里面的对象

       通过javap查看生成的class文件，可以发现synchronized的实现：
           同步代码块是使用monitorenter和monitorexit指令实现的。

           任何一个对象都有一个monitor与之相关联，当且一个monitor被持有之后，它将处于锁定
       状态。线程执行到monitorenter指令时，将会尝试获取对象锁对应的monitor所有权，即尝试
       获取对象的锁；

       Java对象头和monitor是实现synchronized的基础。
           synchronized用的锁是存在Java对象头里的，Hotspot虚拟机的对象头主要包括两部
       分数据：Mark Word（标记字段）、Klass Pointer（类型指针）。其中Klass Point是是对
       象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例，
       Mark Word用于存储对象自身的运行时数据，它是实现轻量级锁和偏向锁的关键

       MarkWorld用于存储对象自身的运行时数据，如哈希吗，GC分代年龄，锁状态标志，线程持有的
       锁，偏向线程ID，偏向时间戳等等，Java对象头一般占用2个机器码，每个机器码4个字节，如
       果对象是数组，则需要3个机器码，
</pre>